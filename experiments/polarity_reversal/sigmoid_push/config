#  Config
POLARITY_REV_1_CONFIG = {
    SUBSTRATE_TYPE: CONTINUOUS_GRADIENTS,
    CUSTOM_FIRST: 0,
    CUSTOM_SECOND: 0,
    ROWS: 3,  # number of rows = max value along y-axis
    COLS: 10,  # number of cols = max value along x-axis
    GC_COUNT: 80,
    GC_SIZE: 2,
    STEP_SIZE: 1,
    STEP_AMOUNT: 1000,
    X_STEP_POSSIBILITY: 0.55,
    Y_STEP_POSSIBILITY: 0.50,
    SIGMOID_GAIN: 12,
    SIGMA: 0.05,
    FORCE: False,
    FORWARD_SIG: True,
    REVERSE_SIG: True,
    FF_INTER: False,
    FT_INTER: True,
    ADAPTATION_ENABLED: False,
    ADAPTATION_MU: 0.01,  # 0.01
    ADAPTATION_LAMBDA: 0.0045,  # 0.0045
    ADAPTATION_HISTORY: 40  # 30
}

POLARITY_REV_2_CONFIG = {
    SUBSTRATE_TYPE: CONTINUOUS_GRADIENTS,
    CUSTOM_FIRST: 0,
    CUSTOM_SECOND: 0,
    ROWS: 3,  # number of rows = max value along y-axis
    COLS: 10,  # number of cols = max value along x-axis
    GC_COUNT: 80,
    GC_SIZE: 2,
    STEP_SIZE: 1,
    STEP_AMOUNT: 1000,
    X_STEP_POSSIBILITY: 0.50,
    Y_STEP_POSSIBILITY: 0.50,
    SIGMOID_GAIN: 30,
    SIGMA: 0.05,
    FORCE: False,
    FORWARD_SIG: True,
    REVERSE_SIG: True,
    FF_INTER: True,
    FT_INTER: True,
    ADAPTATION_ENABLED: False,
    ADAPTATION_MU: 0.01,  # 0.01
    ADAPTATION_LAMBDA: 0.0045,  # 0.0045
    ADAPTATION_HISTORY: 40  # 30
}

def calculate_step_ratio(step, num_steps, sigmoid_gain, push_left=0.9):
    def sigmoid(x):
        return 1 / (1 + math.exp(-x))

    adjusted_step = step + push_left * num_steps  # Moves the midpoint left
    mid_scaled_value = sigmoid_gain * (2 * (adjusted_step / num_steps))

    step_ratio = sigmoid(mid_scaled_value)
    return step_ratio